# Copyright 2025 CNOE
# SPDX-License-Identifier: Apache-2.0
# Generated by CNOE OpenAPI MCP Codegen tool

"""Tools for /api/v1/sensors/{namespace}/{name} operations"""

import logging
from typing import Dict, Any, List
from mcp_argo_workflows.api.client import make_api_request, assemble_nested_body

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("mcp_tools")


async def get_sns_svc_get_sns(path_namespace: str, path_name: str, param_get_options_resource_version: str = None) -> Any:
  """


      OpenAPI Description:


      Args:

          path_namespace (str): OpenAPI parameter corresponding to 'path_namespace'

          path_name (str): OpenAPI parameter corresponding to 'path_name'

          param_get_options_resource_version (str): resourceVersion sets a constraint on what resource versions a request may be served from.
  See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
  details.

  Defaults to unset
  +optional


      Returns:
          Any: The JSON response from the API call.

      Raises:
          Exception: If the API request fails or returns an error.
  """
  logger.debug("Making GET request to /api/v1/sensors/{namespace}/{name}")

  params = {}
  data = {}

  if param_get_options_resource_version is not None:
    params["get_options_resource_version"] = (
      str(param_get_options_resource_version).lower()
      if isinstance(param_get_options_resource_version, bool)
      else param_get_options_resource_version
    )

  flat_body = {}
  data = assemble_nested_body(flat_body)

  success, response = await make_api_request(f"/api/v1/sensors/{path_namespace}/{path_name}", method="GET", params=params, data=data)

  if not success:
    logger.error(f"Request failed: {response.get('error')}")
    return {"error": response.get("error", "Request failed")}
  return response


async def put_sns_svc_upd_sns(
  path_namespace: str,
  path_name: str,
  body_name: str = None,
  body_namespace: str = None,
  body_sensor_metadata: Dict[str, Any] = None,
  body_sensor_spec_dependencies: List[Dict[str, Any]] = None,
  body_sensor_spec_error_on_failed_round: bool = None,
  body_sensor_spec_event_bus_name: str = None,
  body_sensor_spec_logging_fields: Dict[str, Any] = None,
  body_sensor_spec_replicas: int = None,
  body_sensor_spec_revision_history_limit: int = None,
  body_sensor_spec_template: Dict[str, Any] = None,
  body_sensor_spec_triggers: List[Dict[str, Any]] = None,
  body_sensor_status_status_conditions: List[Dict[str, Any]] = None,
) -> Any:
  """


      OpenAPI Description:


      Args:

          path_namespace (str): OpenAPI parameter corresponding to 'path_namespace'

          path_name (str): OpenAPI parameter corresponding to 'path_name'

          body_name (str): OpenAPI parameter corresponding to 'body_name'

          body_namespace (str): OpenAPI parameter corresponding to 'body_namespace'

          body_sensor_metadata (Dict[str, Any]): ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.

          body_sensor_spec_dependencies (List[Dict[str, Any]]): Dependencies is a list of the events that this sensor is dependent on.

          body_sensor_spec_error_on_failed_round (bool): ErrorOnFailedRound if set to true, marks sensor state as `error` if the previous trigger round fails.
  Once sensor state is set to `error`, no further triggers will be processed.

          body_sensor_spec_event_bus_name (str): OpenAPI parameter corresponding to 'body_sensor_spec_event_bus_name'

          body_sensor_spec_logging_fields (Dict[str, Any]): OpenAPI parameter corresponding to 'body_sensor_spec_logging_fields'

          body_sensor_spec_replicas (int): OpenAPI parameter corresponding to 'body_sensor_spec_replicas'

          body_sensor_spec_revision_history_limit (int): OpenAPI parameter corresponding to 'body_sensor_spec_revision_history_limit'

          body_sensor_spec_template (Dict[str, Any]): Request body as dictionary. Contains 11 nested properties. See OpenAPI schema for detailed structure.

          body_sensor_spec_triggers (List[Dict[str, Any]]): Triggers is a list of the things that this sensor evokes. These are the outputs from this sensor.

          body_sensor_status_status_conditions (List[Dict[str, Any]]): OpenAPI parameter corresponding to 'body_sensor_status_status_conditions'


      Returns:
          Any: The JSON response from the API call.

      Raises:
          Exception: If the API request fails or returns an error.
  """
  logger.debug("Making PUT request to /api/v1/sensors/{namespace}/{name}")

  params = {}
  data = {}

  flat_body = {}
  if body_name is not None:
    flat_body["name"] = body_name
  if body_namespace is not None:
    flat_body["namespace"] = body_namespace
  if body_sensor_metadata is not None:
    flat_body["sensor_metadata"] = body_sensor_metadata
  if body_sensor_spec_dependencies is not None:
    flat_body["sensor_spec_dependencies"] = body_sensor_spec_dependencies
  if body_sensor_spec_error_on_failed_round is not None:
    flat_body["sensor_spec_error_on_failed_round"] = body_sensor_spec_error_on_failed_round
  if body_sensor_spec_event_bus_name is not None:
    flat_body["sensor_spec_event_bus_name"] = body_sensor_spec_event_bus_name
  if body_sensor_spec_logging_fields is not None:
    flat_body["sensor_spec_logging_fields"] = body_sensor_spec_logging_fields
  if body_sensor_spec_replicas is not None:
    flat_body["sensor_spec_replicas"] = body_sensor_spec_replicas
  if body_sensor_spec_revision_history_limit is not None:
    flat_body["sensor_spec_revision_history_limit"] = body_sensor_spec_revision_history_limit
  if body_sensor_spec_template is not None:
    flat_body["sensor_spec_template"] = body_sensor_spec_template
  if body_sensor_spec_triggers is not None:
    flat_body["sensor_spec_triggers"] = body_sensor_spec_triggers
  if body_sensor_status_status_conditions is not None:
    flat_body["sensor_status_status_conditions"] = body_sensor_status_status_conditions
  data = assemble_nested_body(flat_body)

  success, response = await make_api_request(f"/api/v1/sensors/{path_namespace}/{path_name}", method="PUT", params=params, data=data)

  if not success:
    logger.error(f"Request failed: {response.get('error')}")
    return {"error": response.get("error", "Request failed")}
  return response


async def del_sns_svc_del_sns(
  path_namespace: str,
  path_name: str,
  param_delete_options_grace_period_seconds: str = None,
  param_delete_options_preconditions_uid: str = None,
  param_delete_options_preconditions_resource_version: str = None,
  param_delete_options_orphan_dependents: bool = False,
  param_delete_options_propagation_policy: str = None,
  param_delete_options_dry_run: List[str] = None,
  param_delete_options_ignore_store_read_error_with_cluster_breaking_potential: bool = False,
) -> Any:
  """


      OpenAPI Description:


      Args:

          path_namespace (str): OpenAPI parameter corresponding to 'path_namespace'

          path_name (str): OpenAPI parameter corresponding to 'path_name'

          param_delete_options_grace_period_seconds (str): The duration in seconds before the object should be deleted. Value must be non-negative integer.
  The value zero indicates delete immediately. If this value is nil, the default grace period for the
  specified type will be used.
  Defaults to a per object value if not specified. zero means delete immediately.
  +optional.

          param_delete_options_preconditions_uid (str): Specifies the target UID.
  +optional.

          param_delete_options_preconditions_resource_version (str): Specifies the target ResourceVersion
  +optional.

          param_delete_options_orphan_dependents (bool): Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
  Should the dependent objects be orphaned. If true/false, the "orphan"
  finalizer will be added to/removed from the object's finalizers list.
  Either this field or PropagationPolicy may be set, but not both.
  +optional.

          param_delete_options_propagation_policy (str): Whether and how garbage collection will be performed.
  Either this field or OrphanDependents may be set, but not both.
  The default policy is decided by the existing finalizer set in the
  metadata.finalizers and the resource-specific default policy.
  Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
  allow the garbage collector to delete the dependents in the background;
  'Foreground' - a cascading policy that deletes all dependents in the
  foreground.
  +optional.

          param_delete_options_dry_run (List[str]): When present, indicates that modifications should not be
  persisted. An invalid or unrecognized dryRun directive will
  result in an error response and no further processing of the
  request. Valid values are:
  - All: all dry run stages will be processed
  +optional
  +listType=atomic.

          param_delete_options_ignore_store_read_error_with_cluster_breaking_potential (bool): if set to true, it will trigger an unsafe deletion of the resource in
  case the normal deletion flow fails with a corrupt object error.
  A resource is considered corrupt if it can not be retrieved from
  the underlying storage successfully because of a) its data can
  not be transformed e.g. decryption failure, or b) it fails
  to decode into an object.
  NOTE: unsafe deletion ignores finalizer constraints, skips
  precondition checks, and removes the object from the storage.
  WARNING: This may potentially break the cluster if the workload
  associated with the resource being unsafe-deleted relies on normal
  deletion flow. Use only if you REALLY know what you are doing.
  The default value is false, and the user must opt in to enable it
  +optional.


      Returns:
          Any: The JSON response from the API call.

      Raises:
          Exception: If the API request fails or returns an error.
  """
  logger.debug("Making DELETE request to /api/v1/sensors/{namespace}/{name}")

  params = {}
  data = {}

  if param_delete_options_grace_period_seconds is not None:
    params["delete_options_grace_period_seconds"] = (
      str(param_delete_options_grace_period_seconds).lower()
      if isinstance(param_delete_options_grace_period_seconds, bool)
      else param_delete_options_grace_period_seconds
    )

  if param_delete_options_preconditions_uid is not None:
    params["delete_options_preconditions_uid"] = (
      str(param_delete_options_preconditions_uid).lower()
      if isinstance(param_delete_options_preconditions_uid, bool)
      else param_delete_options_preconditions_uid
    )

  if param_delete_options_preconditions_resource_version is not None:
    params["delete_options_preconditions_resource_version"] = (
      str(param_delete_options_preconditions_resource_version).lower()
      if isinstance(param_delete_options_preconditions_resource_version, bool)
      else param_delete_options_preconditions_resource_version
    )

  if param_delete_options_orphan_dependents is not None:
    params["delete_options_orphan_dependents"] = (
      str(param_delete_options_orphan_dependents).lower()
      if isinstance(param_delete_options_orphan_dependents, bool)
      else param_delete_options_orphan_dependents
    )

  if param_delete_options_propagation_policy is not None:
    params["delete_options_propagation_policy"] = (
      str(param_delete_options_propagation_policy).lower()
      if isinstance(param_delete_options_propagation_policy, bool)
      else param_delete_options_propagation_policy
    )

  if param_delete_options_dry_run is not None:
    params["delete_options_dry_run"] = (
      str(param_delete_options_dry_run).lower() if isinstance(param_delete_options_dry_run, bool) else param_delete_options_dry_run
    )

  if param_delete_options_ignore_store_read_error_with_cluster_breaking_potential is not None:
    params["delete_options_ignore_store_read_error_with_cluster_breaking_potential"] = (
      str(param_delete_options_ignore_store_read_error_with_cluster_breaking_potential).lower()
      if isinstance(param_delete_options_ignore_store_read_error_with_cluster_breaking_potential, bool)
      else param_delete_options_ignore_store_read_error_with_cluster_breaking_potential
    )

  flat_body = {}
  data = assemble_nested_body(flat_body)

  success, response = await make_api_request(f"/api/v1/sensors/{path_namespace}/{path_name}", method="DELETE", params=params, data=data)

  if not success:
    logger.error(f"Request failed: {response.get('error')}")
    return {"error": response.get("error", "Request failed")}
  return response

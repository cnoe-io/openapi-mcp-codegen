# Copyright 2025 CNOE
# SPDX-License-Identifier: Apache-2.0
# Generated by CNOE OpenAPI MCP Codegen tool

"""Tools for /api/v1/sensors/{namespace}/{name} operations"""

import logging
from typing import Any
from mcp_argo_workflows.api.client import make_api_request, assemble_nested_body

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("mcp_tools")


async def sensor_service_get_sensor(path_namespace: str, path_name: str, param_getOptions_resourceVersion: str = None) -> Any:
  """
  Retrieve sensors information

  OpenAPI Description:
      Retrieves details of a specific sensor. Use when: checking sensor configuration or investigating sensor-related issues.

  Args:

      path_namespace (str): "Kubernetes namespace to locate the sensor"

      path_name (str): "Sensor name to retrieve details from specified namespace"

      param_getOptions_resourceVersion (str): Specifies resource version to retrieve; use for consistency across requests.


  Returns:
      Any: The JSON response from the API call.

  Raises:
      Exception: If the API request fails or returns an error.
  """
  logger.debug("Making GET request to /api/v1/sensors/{namespace}/{name}")

  params = {}
  data = {}

  if param_getOptions_resourceVersion is not None:
    params["getOptions_resourceVersion"] = (
      str(param_getOptions_resourceVersion).lower()
      if isinstance(param_getOptions_resourceVersion, bool)
      else param_getOptions_resourceVersion
    )

  flat_body = {}
  data = assemble_nested_body(flat_body)

  success, response = await make_api_request(f"/api/v1/sensors/{path_namespace}/{path_name}", method="GET", params=params, data=data)

  if not success:
    logger.error(f"Request failed: {response.get('error')}")
    return {"error": response.get("error", "Request failed")}
  return response


async def sensor_service_update_sensor(path_namespace: str, path_name: str) -> Any:
  """
  Update or replace a sensors

  OpenAPI Description:
      Updates sensor configuration. Use when: modifying sensor settings or updating sensor details in a specific namespace.

  Args:

      path_namespace (str): "Kubernetes namespace to locate the sensor for update"

      path_name (str): Sensor name to update in the specified namespace


  Returns:
      Any: The JSON response from the API call.

  Raises:
      Exception: If the API request fails or returns an error.
  """
  logger.debug("Making PUT request to /api/v1/sensors/{namespace}/{name}")

  params = {}
  data = {}

  flat_body = {}
  data = assemble_nested_body(flat_body)

  success, response = await make_api_request(f"/api/v1/sensors/{path_namespace}/{path_name}", method="PUT", params=params, data=data)

  if not success:
    logger.error(f"Request failed: {response.get('error')}")
    return {"error": response.get("error", "Request failed")}
  return response


async def sensor_service_delete_sensor(
  path_namespace: str,
  path_name: str,
  param_deleteOptions_gracePeriodSeconds: int = None,
  param_deleteOptions_preconditions_uid: str = None,
  param_deleteOptions_preconditions_resourceVersion: str = None,
  param_deleteOptions_orphanDependents: bool = False,
  param_deleteOptions_propagationPolicy: str = None,
  param_deleteOptions_dryRun: str = None,
  param_deleteOptions_ignoreStoreReadErrorWithClusterBreakingPotential: str = None,
) -> Any:
  """
  Delete a sensors

  OpenAPI Description:
      Deletes a sensor by name and namespace. Use when: removing obsolete or unwanted sensors from the system.

  Args:

      path_namespace (str): "Kubernetes namespace of the sensor to delete"

      path_name (str): "Sensor name to delete within the specified namespace"

      param_deleteOptions_gracePeriodSeconds (int): Specifies delay in seconds before deletion; use for graceful shutdown.

      param_deleteOptions_preconditions_uid (str): "UID to ensure deletion only if it matches the target sensor's UID"

      param_deleteOptions_preconditions_resourceVersion (str): "Delete only if resource version matches specified value"

      param_deleteOptions_orphanDependents (bool): "Delete without affecting dependents when true (deprecated)"

      param_deleteOptions_propagationPolicy (str): Controls garbage collection method (e.g., "Foreground", "Background") during deletion.

      param_deleteOptions_dryRun (str): Simulate deletion without actual changes (e.g., ["All"]).

      param_deleteOptions_ignoreStoreReadErrorWithClusterBreakingPotential (str): Ignore read errors for unsafe deletion when true


  Returns:
      Any: The JSON response from the API call.

  Raises:
      Exception: If the API request fails or returns an error.
  """
  logger.debug("Making DELETE request to /api/v1/sensors/{namespace}/{name}")

  params = {}
  data = {}

  if param_deleteOptions_gracePeriodSeconds is not None:
    params["deleteOptions_gracePeriodSeconds"] = (
      str(param_deleteOptions_gracePeriodSeconds).lower()
      if isinstance(param_deleteOptions_gracePeriodSeconds, bool)
      else param_deleteOptions_gracePeriodSeconds
    )

  if param_deleteOptions_preconditions_uid is not None:
    params["deleteOptions_preconditions_uid"] = (
      str(param_deleteOptions_preconditions_uid).lower()
      if isinstance(param_deleteOptions_preconditions_uid, bool)
      else param_deleteOptions_preconditions_uid
    )

  if param_deleteOptions_preconditions_resourceVersion is not None:
    params["deleteOptions_preconditions_resourceVersion"] = (
      str(param_deleteOptions_preconditions_resourceVersion).lower()
      if isinstance(param_deleteOptions_preconditions_resourceVersion, bool)
      else param_deleteOptions_preconditions_resourceVersion
    )

  if param_deleteOptions_orphanDependents is not None:
    params["deleteOptions_orphanDependents"] = (
      str(param_deleteOptions_orphanDependents).lower()
      if isinstance(param_deleteOptions_orphanDependents, bool)
      else param_deleteOptions_orphanDependents
    )

  if param_deleteOptions_propagationPolicy is not None:
    params["deleteOptions_propagationPolicy"] = (
      str(param_deleteOptions_propagationPolicy).lower()
      if isinstance(param_deleteOptions_propagationPolicy, bool)
      else param_deleteOptions_propagationPolicy
    )

  if param_deleteOptions_dryRun is not None:
    params["deleteOptions_dryRun"] = (
      str(param_deleteOptions_dryRun).lower() if isinstance(param_deleteOptions_dryRun, bool) else param_deleteOptions_dryRun
    )

  if param_deleteOptions_ignoreStoreReadErrorWithClusterBreakingPotential is not None:
    params["deleteOptions_ignoreStoreReadErrorWithClusterBreakingPotential"] = (
      str(param_deleteOptions_ignoreStoreReadErrorWithClusterBreakingPotential).lower()
      if isinstance(param_deleteOptions_ignoreStoreReadErrorWithClusterBreakingPotential, bool)
      else param_deleteOptions_ignoreStoreReadErrorWithClusterBreakingPotential
    )

  flat_body = {}
  data = assemble_nested_body(flat_body)

  success, response = await make_api_request(f"/api/v1/sensors/{path_namespace}/{path_name}", method="DELETE", params=params, data=data)

  if not success:
    logger.error(f"Request failed: {response.get('error')}")
    return {"error": response.get("error", "Request failed")}
  return response

# Copyright 2025 CNOE
# SPDX-License-Identifier: Apache-2.0
# Generated by CNOE OpenAPI MCP Codegen tool

"""Tools for /api/v1/workflows/{namespace}/{name}/{podName}/log operations"""

import logging
from typing import Any
from mcp_argo_workflows.api.client import make_api_request, assemble_nested_body

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("mcp_tools")


async def workflow_service_pod_logs(
  path_namespace: str,
  path_name: str,
  path_podName: str,
  param_logOptions_container: str = None,
  param_logOptions_follow: bool = False,
  param_logOptions_previous: bool = False,
  param_logOptions_sinceSeconds: int = None,
  param_logOptions_sinceTime_seconds: int = None,
  param_logOptions_sinceTime_nanos: int = None,
  param_logOptions_timestamps: bool = False,
  param_logOptions_tailLines: int = None,
  param_logOptions_limitBytes: int = None,
  param_logOptions_insecureSkipTLSVerifyBackend: bool = False,
  param_logOptions_stream: bool = False,
  param_grep: str = None,
  param_selector: str = None,
) -> Any:
  """
  DEPRECATED: Cannot work via HTTP if podName is an empty string. Use WorkflowLogs.

  OpenAPI Description:
      Retrieves logs for a specific pod in a workflow. Use when: accessing pod logs for debugging or monitoring purposes. Note: Deprecated, use WorkflowLogs if podName is empty.

  Args:

      path_namespace (str): "Kubernetes namespace to locate the workflow"

      path_name (str): Workflow name to retrieve specific details

      path_podName (str): Specific pod name to retrieve details within the workflow.

      param_logOptions_container (str): Specifies container to stream logs from; use if pod has multiple containers.

      param_logOptions_follow (bool): Stream live pod logs when true; default is false. Use for real-time monitoring.

      param_logOptions_previous (bool): Return logs from previous container run when true. Use for terminated containers.

      param_logOptions_sinceSeconds (int): Specifies logs from seconds ago; use for recent activity analysis.

      param_logOptions_sinceTime_seconds (int): Specify UTC seconds since epoch to filter logs from that time onward.

      param_logOptions_sinceTime_nanos (int): Specifies nanoseconds for log start time; use for precise log retrieval.

      param_logOptions_timestamps (bool): Add timestamps to log lines when true (use for detailed time tracking)

      param_logOptions_tailLines (int): "Number of log lines from end to display (e.g., 100)"

      param_logOptions_limitBytes (int): Specifies max bytes to read from logs; use to limit log size.

      param_logOptions_insecureSkipTLSVerifyBackend (bool): Skip TLS verification for backend when true (use cautiously)

      param_logOptions_stream (bool): Specifies log stream type: "All", "Stdout", or "Stderr" for container logs.

      param_grep (str): Specifies text pattern to filter logs (e.g., "error")

      param_selector (str): Criteria to filter workflows (e.g., status=active)


  Returns:
      Any: The JSON response from the API call.

  Raises:
      Exception: If the API request fails or returns an error.
  """
  logger.debug("Making GET request to /api/v1/workflows/{namespace}/{name}/{podName}/log")

  params = {}
  data = {}

  if param_logOptions_container is not None:
    params["logOptions_container"] = (
      str(param_logOptions_container).lower() if isinstance(param_logOptions_container, bool) else param_logOptions_container
    )

  if param_logOptions_follow is not None:
    params["logOptions_follow"] = (
      str(param_logOptions_follow).lower() if isinstance(param_logOptions_follow, bool) else param_logOptions_follow
    )

  if param_logOptions_previous is not None:
    params["logOptions_previous"] = (
      str(param_logOptions_previous).lower() if isinstance(param_logOptions_previous, bool) else param_logOptions_previous
    )

  if param_logOptions_sinceSeconds is not None:
    params["logOptions_sinceSeconds"] = (
      str(param_logOptions_sinceSeconds).lower() if isinstance(param_logOptions_sinceSeconds, bool) else param_logOptions_sinceSeconds
    )

  if param_logOptions_sinceTime_seconds is not None:
    params["logOptions_sinceTime_seconds"] = (
      str(param_logOptions_sinceTime_seconds).lower()
      if isinstance(param_logOptions_sinceTime_seconds, bool)
      else param_logOptions_sinceTime_seconds
    )

  if param_logOptions_sinceTime_nanos is not None:
    params["logOptions_sinceTime_nanos"] = (
      str(param_logOptions_sinceTime_nanos).lower()
      if isinstance(param_logOptions_sinceTime_nanos, bool)
      else param_logOptions_sinceTime_nanos
    )

  if param_logOptions_timestamps is not None:
    params["logOptions_timestamps"] = (
      str(param_logOptions_timestamps).lower() if isinstance(param_logOptions_timestamps, bool) else param_logOptions_timestamps
    )

  if param_logOptions_tailLines is not None:
    params["logOptions_tailLines"] = (
      str(param_logOptions_tailLines).lower() if isinstance(param_logOptions_tailLines, bool) else param_logOptions_tailLines
    )

  if param_logOptions_limitBytes is not None:
    params["logOptions_limitBytes"] = (
      str(param_logOptions_limitBytes).lower() if isinstance(param_logOptions_limitBytes, bool) else param_logOptions_limitBytes
    )

  if param_logOptions_insecureSkipTLSVerifyBackend is not None:
    params["logOptions_insecureSkipTLSVerifyBackend"] = (
      str(param_logOptions_insecureSkipTLSVerifyBackend).lower()
      if isinstance(param_logOptions_insecureSkipTLSVerifyBackend, bool)
      else param_logOptions_insecureSkipTLSVerifyBackend
    )

  if param_logOptions_stream is not None:
    params["logOptions_stream"] = (
      str(param_logOptions_stream).lower() if isinstance(param_logOptions_stream, bool) else param_logOptions_stream
    )

  if param_grep is not None:
    params["grep"] = str(param_grep).lower() if isinstance(param_grep, bool) else param_grep

  if param_selector is not None:
    params["selector"] = str(param_selector).lower() if isinstance(param_selector, bool) else param_selector

  flat_body = {}
  data = assemble_nested_body(flat_body)

  success, response = await make_api_request(
    f"/api/v1/workflows/{path_namespace}/{path_name}/{path_podName}/log", method="GET", params=params, data=data
  )

  if not success:
    logger.error(f"Request failed: {response.get('error')}")
    return {"error": response.get("error", "Request failed")}
  return response

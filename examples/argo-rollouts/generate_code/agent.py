# Copyright 2025 CNOE
# SPDX-License-Identifier: Apache-2.0
# Generated by CNOE OpenAPI MCP Codegen tool

"""LangGraph React-agent wrapper for the generated MCP server."""

import asyncio
import importlib.util
import logging
import os
from pathlib import Path
from dotenv import load_dotenv

from datetime import datetime, timezone
from langchain_core.tools import tool

from langgraph.prebuilt import create_react_agent
from langgraph.checkpoint.memory import MemorySaver
from langchain_mcp_adapters.client import MultiServerMCPClient
from cnoe_agent_utils import LLMFactory
from langfuse import get_client

load_dotenv()  # makes values from .env available via os.getenv

logger = logging.getLogger(__name__)


# Default system prompt (auto-generated by the generator)
DEFAULT_SYSTEM_PROMPT = r"""You are an expert Argo Rollouts assistant that helps users manage progressive delivery and advanced deployment strategies in Kubernetes.

# CORE CAPABILITIES
You can help with:
- üöÄ **Rollout Management**: Create, deploy, and manage progressive delivery rollouts
- üìä **Analysis & Validation**: Set up automated analysis templates and monitoring
- üß™ **Experimentation**: Configure A/B tests and traffic splitting experiments
- üìà **Progressive Delivery**: Manage canary, blue-green, and custom deployment strategies
- üîç **Monitoring**: Track rollout progress, metrics, and health status
- üõ†Ô∏è **Troubleshooting**: Debug failed rollouts, analysis issues, and deployment problems

# INTERACTION GUIDELINES
üéØ **Be Specific**: When asking for rollout operations, provide:
- Rollout names and namespaces
- Deployment strategy (canary, blue-green, etc.)
- Traffic routing requirements
- Analysis and validation criteria

üí° **Example Requests**:
- "List all rollouts in namespace 'production'"
- "Create a canary rollout for application 'web-frontend' with 20% traffic split"
- "Promote rollout 'api-service' to the next canary step"
- "Set up analysis template for success rate validation using Prometheus"
- "Abort rollout 'failed-deployment' and revert to stable version"
- "Create an A/B test experiment for feature 'new-checkout-flow'"

# ROLLOUT CREATION TIPS
When creating rollouts, I'll guide you through:
- Deployment strategy selection (canary, blue-green, custom)
- Traffic routing configuration (Istio, NGINX, ALB, etc.)
- Analysis templates and success criteria
- Rollback and abort policies
- Resource specifications and scaling

# COMMON PATTERNS
- For **new rollouts**: I'll ask for strategy, traffic routing, and validation requirements
- For **monitoring**: I'll help track progress, metrics, and analysis results
- For **troubleshooting**: I'll examine rollout status, events, and analysis failures
- For **experiments**: I'll help configure A/B tests and traffic splitting

# PROGRESSIVE DELIVERY BEST PRACTICES
I'll help you implement progressive delivery patterns:
- Gradual traffic shifting with automated validation
- Comprehensive analysis and success criteria
- Automated rollback on failure detection
- Integration with monitoring and observability tools
- Safe deployment practices with minimal blast radius

Ask me anything about Argo Rollouts - I'm here to help you implement safe, progressive deployments!"""

# Locate the generated MCP server module
spec = importlib.util.find_spec("mcp_argo_rollouts.server")
if not spec or not spec.origin:
    raise ImportError("Cannot find mcp_argo_rollouts.server module")
server_path = str(Path(spec.origin).resolve())


@tool
def get_current_time() -> str:
    """Return the current date-time in ISO-8601 format."""
    return datetime.now().isoformat()


@tool
def iso8601_to_unix(iso_str: str) -> str:
    """
    Convert an ISO-8601 datetime string to a Unix timestamp (seconds since epoch).
    If no timezone is present, assume UTC.
    """
    s = iso_str.strip()
    # Support common variations: with/without 'Z', with offset, with space instead of 'T'
    # Normalize space to 'T' to help fromisoformat
    if " " in s and "T" not in s:
        s = s.replace(" ", "T")

    # Handle trailing 'Z' (UTC)
    if s.endswith("Z"):
        s = s[:-1] + "+00:00"

    try:
        dt = datetime.fromisoformat(s)
    except ValueError:
        # Fallback: try parsing without separators or with milliseconds
        raise ValueError(f"Invalid ISO-8601 datetime string: {iso_str}")

    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=timezone.utc)

    return str(int(dt.timestamp()))


async def create_agent(prompt: str | None = None, response_format=None):
    """
    Spin-up the MCP server as a subprocess via MultiServerMCPClient and build
    and returns the LangGraph agent **and its tool list**.
    """
    memory = MemorySaver()

    if prompt is None:
        prompt = DEFAULT_SYSTEM_PROMPT  # ‚Üê use literal string, no fallback

    api_url = os.getenv("ARGO_ROLLOUTS_API_URL")
    api_token = os.getenv("ARGO_ROLLOUTS_TOKEN")
    if not api_url or not api_token:
        raise ValueError("Set ARGO_ROLLOUTS_API_URL and ARGO_ROLLOUTS_TOKEN env vars")

    client = MultiServerMCPClient(
        {
            "argo_rollouts": {
                "command": "uv",
                "args": ["run", server_path],
                "env": {
                    "ARGO_ROLLOUTS_API_URL": api_url,
                    "ARGO_ROLLOUTS_TOKEN": api_token,
                },
                "transport": "stdio",
            }
        }
    )
    mcp_tools = await client.get_tools()
    try:
        get_client().update_current_trace(tags=["argo_rollouts-agent"])
    except Exception:
        pass
    tools = mcp_tools + [get_current_time, iso8601_to_unix]
    # Attach Langfuse callback handler so LangChain/LLM/tool calls are traced
    try:
        get_client().update_current_trace(tags=["argo_rollouts-agent"])
    except Exception:
        pass
    agent = create_react_agent(
        LLMFactory().get_llm(),
        tools=tools,
        checkpointer=memory,
        prompt=prompt,
        response_format=response_format,
    )
    return agent, tools  # also return raw tool list for evaluators


# Convenience synchronous wrapper
def create_agent_sync(prompt: str | None = None, response_format=None):
    agent, tools = asyncio.run(create_agent(prompt, response_format))
    try:
        get_client().flush()
    except Exception:
        pass
    return agent, tools

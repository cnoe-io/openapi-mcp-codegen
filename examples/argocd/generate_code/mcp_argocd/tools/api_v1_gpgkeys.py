# Copyright 2025 CNOE
# SPDX-License-Identifier: Apache-2.0
# Generated by CNOE OpenAPI MCP Codegen tool

"""Tools for /api/v1/gpgkeys operations"""

import logging
from typing import Any
from mcp_argocd.api.client import make_api_request, assemble_nested_body

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("mcp_tools")


async def get_gpg_key_svc_ls(param_key_id: str = None) -> Any:
  """
  List all available repository certificates

  OpenAPI Description:


  Args:

      param_key_id (str): The GPG key ID to query for.


  Returns:
      Any: The JSON response from the API call.

  Raises:
      Exception: If the API request fails or returns an error.
  """
  logger.debug("Making GET request to /api/v1/gpgkeys")

  params = {}
  data = {}

  if param_key_id is not None:
    params["key_id"] = str(param_key_id).lower() if isinstance(param_key_id, bool) else param_key_id

  flat_body = {}
  data = assemble_nested_body(flat_body)

  success, response = await make_api_request("/api/v1/gpgkeys", method="GET", params=params, data=data)

  if not success:
    logger.error(f"Request failed: {response.get('error')}")
    return {"error": response.get("error", "Request failed")}
  return response


async def post_gpg_key_svc_new(
  body_fingerprint: str = None,
  body_key_data: str = None,
  body_key_id: str = None,
  body_owner: str = None,
  body_sub_type: str = None,
  body_trust: str = None,
  param_upsert: bool = False,
) -> Any:
  """
  Create one or more GPG public keys in the server's configuration

  OpenAPI Description:


  Args:

      body_fingerprint (str): OpenAPI parameter corresponding to 'body_fingerprint'

      body_key_data (str): OpenAPI parameter corresponding to 'body_key_data'

      body_key_id (str): OpenAPI parameter corresponding to 'body_key_id'

      body_owner (str): OpenAPI parameter corresponding to 'body_owner'

      body_sub_type (str): OpenAPI parameter corresponding to 'body_sub_type'

      body_trust (str): OpenAPI parameter corresponding to 'body_trust'

      param_upsert (bool): Whether to upsert already existing public keys.


  Returns:
      Any: The JSON response from the API call.

  Raises:
      Exception: If the API request fails or returns an error.
  """
  logger.debug("Making POST request to /api/v1/gpgkeys")

  params = {}
  data = {}

  if param_upsert is not None:
    params["upsert"] = str(param_upsert).lower() if isinstance(param_upsert, bool) else param_upsert

  flat_body = {}
  if body_fingerprint is not None:
    flat_body["fingerprint"] = body_fingerprint
  if body_key_data is not None:
    flat_body["key_data"] = body_key_data
  if body_key_id is not None:
    flat_body["key_id"] = body_key_id
  if body_owner is not None:
    flat_body["owner"] = body_owner
  if body_sub_type is not None:
    flat_body["sub_type"] = body_sub_type
  if body_trust is not None:
    flat_body["trust"] = body_trust
  data = assemble_nested_body(flat_body)

  success, response = await make_api_request("/api/v1/gpgkeys", method="POST", params=params, data=data)

  if not success:
    logger.error(f"Request failed: {response.get('error')}")
    return {"error": response.get("error", "Request failed")}
  return response


async def del_gpg_key_svc_del(param_key_id: str = None) -> Any:
  """
  Delete specified GPG public key from the server's configuration

  OpenAPI Description:


  Args:

      param_key_id (str): The GPG key ID to query for.


  Returns:
      Any: The JSON response from the API call.

  Raises:
      Exception: If the API request fails or returns an error.
  """
  logger.debug("Making DELETE request to /api/v1/gpgkeys")

  params = {}
  data = {}

  if param_key_id is not None:
    params["key_id"] = str(param_key_id).lower() if isinstance(param_key_id, bool) else param_key_id

  flat_body = {}
  data = assemble_nested_body(flat_body)

  success, response = await make_api_request("/api/v1/gpgkeys", method="DELETE", params=params, data=data)

  if not success:
    logger.error(f"Request failed: {response.get('error')}")
    return {"error": response.get("error", "Request failed")}
  return response

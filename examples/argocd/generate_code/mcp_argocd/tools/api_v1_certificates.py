# Copyright 2025 CNOE
# SPDX-License-Identifier: Apache-2.0
# Generated by CNOE OpenAPI MCP Codegen tool

"""Tools for /api/v1/certificates operations"""

import logging
from typing import Dict, Any, List
from mcp_argocd.api.client import make_api_request, assemble_nested_body

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("mcp_tools")


async def get_certificate_svc_certificates(
  param_host_name_pattern: str = None, param_cert_type: str = None, param_cert_sub_type: str = None
) -> Any:
  """
  List all available repository certificates

  OpenAPI Description:


  Args:

      param_host_name_pattern (str): A file-glob pattern (not regular expression) the host name has to match.

      param_cert_type (str): The type of the certificate to match (ssh or https).

      param_cert_sub_type (str): The sub type of the certificate to match (protocol dependent, usually only used for ssh certs).


  Returns:
      Any: The JSON response from the API call.

  Raises:
      Exception: If the API request fails or returns an error.
  """
  logger.debug("Making GET request to /api/v1/certificates")

  params = {}
  data = {}

  if param_host_name_pattern is not None:
    params["host_name_pattern"] = (
      str(param_host_name_pattern).lower() if isinstance(param_host_name_pattern, bool) else param_host_name_pattern
    )

  if param_cert_type is not None:
    params["cert_type"] = str(param_cert_type).lower() if isinstance(param_cert_type, bool) else param_cert_type

  if param_cert_sub_type is not None:
    params["cert_sub_type"] = str(param_cert_sub_type).lower() if isinstance(param_cert_sub_type, bool) else param_cert_sub_type

  flat_body = {}
  data = assemble_nested_body(flat_body)

  success, response = await make_api_request("/api/v1/certificates", method="GET", params=params, data=data)

  if not success:
    logger.error(f"Request failed: {response.get('error')}")
    return {"error": response.get("error", "Request failed")}
  return response


async def post_certificate_svc_certificate(
  body_items: List[Dict[str, Any]] = None,
  body_metadata_continue: str = None,
  body_metadata_remaining_item_count: int = None,
  body_metadata_resource_version: str = None,
  body_metadata_self_link: str = None,
  param_upsert: bool = False,
) -> Any:
  """
      Creates repository certificates on the server

      OpenAPI Description:


      Args:

          body_items (List[Dict[str, Any]]): OpenAPI parameter corresponding to 'body_items'

          body_metadata_continue (str): continue may be set if the user set a limit on the number of items returned, and indicates that
  the server has more data available. The value is opaque and may be used to issue another request
  to the endpoint that served this list to retrieve the next set of available objects. Continuing a
  consistent list may not be possible if the server configuration has changed or more than a few
  minutes have passed. The resourceVersion field returned when using this continue value will be
  identical to the value in the first response, unless you have received this token from an error
  message.

          body_metadata_remaining_item_count (int): OpenAPI parameter corresponding to 'body_metadata_remaining_item_count'

          body_metadata_resource_version (str): OpenAPI parameter corresponding to 'body_metadata_resource_version'

          body_metadata_self_link (str): OpenAPI parameter corresponding to 'body_metadata_self_link'

          param_upsert (bool): Whether to upsert already existing certificates.


      Returns:
          Any: The JSON response from the API call.

      Raises:
          Exception: If the API request fails or returns an error.
  """
  logger.debug("Making POST request to /api/v1/certificates")

  params = {}
  data = {}

  if param_upsert is not None:
    params["upsert"] = str(param_upsert).lower() if isinstance(param_upsert, bool) else param_upsert

  flat_body = {}
  if body_items is not None:
    flat_body["items"] = body_items
  if body_metadata_continue is not None:
    flat_body["metadata_continue"] = body_metadata_continue
  if body_metadata_remaining_item_count is not None:
    flat_body["metadata_remaining_item_count"] = body_metadata_remaining_item_count
  if body_metadata_resource_version is not None:
    flat_body["metadata_resource_version"] = body_metadata_resource_version
  if body_metadata_self_link is not None:
    flat_body["metadata_self_link"] = body_metadata_self_link
  data = assemble_nested_body(flat_body)

  success, response = await make_api_request("/api/v1/certificates", method="POST", params=params, data=data)

  if not success:
    logger.error(f"Request failed: {response.get('error')}")
    return {"error": response.get("error", "Request failed")}
  return response


async def del_certificate_svc_certificate(
  param_host_name_pattern: str = None, param_cert_type: str = None, param_cert_sub_type: str = None
) -> Any:
  """
  Delete the certificates that match the RepositoryCertificateQuery

  OpenAPI Description:


  Args:

      param_host_name_pattern (str): A file-glob pattern (not regular expression) the host name has to match.

      param_cert_type (str): The type of the certificate to match (ssh or https).

      param_cert_sub_type (str): The sub type of the certificate to match (protocol dependent, usually only used for ssh certs).


  Returns:
      Any: The JSON response from the API call.

  Raises:
      Exception: If the API request fails or returns an error.
  """
  logger.debug("Making DELETE request to /api/v1/certificates")

  params = {}
  data = {}

  if param_host_name_pattern is not None:
    params["host_name_pattern"] = (
      str(param_host_name_pattern).lower() if isinstance(param_host_name_pattern, bool) else param_host_name_pattern
    )

  if param_cert_type is not None:
    params["cert_type"] = str(param_cert_type).lower() if isinstance(param_cert_type, bool) else param_cert_type

  if param_cert_sub_type is not None:
    params["cert_sub_type"] = str(param_cert_sub_type).lower() if isinstance(param_cert_sub_type, bool) else param_cert_sub_type

  flat_body = {}
  data = assemble_nested_body(flat_body)

  success, response = await make_api_request("/api/v1/certificates", method="DELETE", params=params, data=data)

  if not success:
    logger.error(f"Request failed: {response.get('error')}")
    return {"error": response.get("error", "Request failed")}
  return response

# Copyright 2025 CNOE
# SPDX-License-Identifier: Apache-2.0
# Generated by CNOE OpenAPI MCP Codegen tool

"""Tools for /api/v1/repositories/{repo}/validate operations"""

import logging
from typing import Any
from mcp_argocd.api.client import make_api_request, assemble_nested_body

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("mcp_tools")


async def post_repository_svc_validate_access(
  path_repo: str,
  body: str,
  param_username: str = None,
  param_password: str = None,
  param_ssh_private_key: str = None,
  param_insecure: bool = False,
  param_tls_client_cert_data: str = None,
  param_tls_client_cert_key: str = None,
  param_type: str = None,
  param_name: str = None,
  param_enable_oci: bool = False,
  param_github_app_private_key: str = None,
  param_github_app_id: str = None,
  param_github_app_installation_id: str = None,
  param_github_app_enterprise_base_url: str = None,
  param_proxy: str = None,
  param_project: str = None,
  param_gcp_service_account_key: str = None,
  param_force_http_basic_auth: bool = False,
  param_use_azure_workload_identity: bool = False,
  param_bearer_token: str = None,
  param_insecure_oci_force_http: bool = False,
) -> Any:
  """
  ValidateAccess validates access to a repository with given parameters

  OpenAPI Description:


  Args:

      path_repo (str): The URL to the repo

      body (str): OpenAPI parameter corresponding to 'body'

      param_username (str): Username for accessing repo.

      param_password (str): Password for accessing repo.

      param_ssh_private_key (str): Private key data for accessing SSH repository.

      param_insecure (bool): Whether to skip certificate or host key validation.

      param_tls_client_cert_data (str): TLS client cert data for accessing HTTPS repository.

      param_tls_client_cert_key (str): TLS client cert key for accessing HTTPS repository.

      param_type (str): The type of the repo.

      param_name (str): The name of the repo.

      param_enable_oci (bool): Whether helm-oci support should be enabled for this repo.

      param_github_app_private_key (str): Github App Private Key PEM data.

      param_github_app_id (str): Github App ID of the app used to access the repo.

      param_github_app_installation_id (str): Github App Installation ID of the installed GitHub App.

      param_github_app_enterprise_base_url (str): Github App Enterprise base url if empty will default to https://api.github.com.

      param_proxy (str): HTTP/HTTPS proxy to access the repository.

      param_project (str): Reference between project and repository that allow you automatically to be added as item inside SourceRepos project entity.

      param_gcp_service_account_key (str): Google Cloud Platform service account key.

      param_force_http_basic_auth (bool): Whether to force HTTP basic auth.

      param_use_azure_workload_identity (bool): Whether to use azure workload identity for authentication.

      param_bearer_token (str): BearerToken contains the bearer token used for Git auth at the repo server.

      param_insecure_oci_force_http (bool): Whether https should be disabled for an OCI repo.


  Returns:
      Any: The JSON response from the API call.

  Raises:
      Exception: If the API request fails or returns an error.
  """
  logger.debug("Making POST request to /api/v1/repositories/{repo}/validate")

  params = {}
  data = {}

  if param_username is not None:
    params["username"] = str(param_username).lower() if isinstance(param_username, bool) else param_username

  if param_password is not None:
    params["password"] = str(param_password).lower() if isinstance(param_password, bool) else param_password

  if param_ssh_private_key is not None:
    params["ssh_private_key"] = str(param_ssh_private_key).lower() if isinstance(param_ssh_private_key, bool) else param_ssh_private_key

  if param_insecure is not None:
    params["insecure"] = str(param_insecure).lower() if isinstance(param_insecure, bool) else param_insecure

  if param_tls_client_cert_data is not None:
    params["tls_client_cert_data"] = (
      str(param_tls_client_cert_data).lower() if isinstance(param_tls_client_cert_data, bool) else param_tls_client_cert_data
    )

  if param_tls_client_cert_key is not None:
    params["tls_client_cert_key"] = (
      str(param_tls_client_cert_key).lower() if isinstance(param_tls_client_cert_key, bool) else param_tls_client_cert_key
    )

  if param_type is not None:
    params["type"] = str(param_type).lower() if isinstance(param_type, bool) else param_type

  if param_name is not None:
    params["name"] = str(param_name).lower() if isinstance(param_name, bool) else param_name

  if param_enable_oci is not None:
    params["enable_oci"] = str(param_enable_oci).lower() if isinstance(param_enable_oci, bool) else param_enable_oci

  if param_github_app_private_key is not None:
    params["github_app_private_key"] = (
      str(param_github_app_private_key).lower() if isinstance(param_github_app_private_key, bool) else param_github_app_private_key
    )

  if param_github_app_id is not None:
    params["github_app_id"] = str(param_github_app_id).lower() if isinstance(param_github_app_id, bool) else param_github_app_id

  if param_github_app_installation_id is not None:
    params["github_app_installation_id"] = (
      str(param_github_app_installation_id).lower()
      if isinstance(param_github_app_installation_id, bool)
      else param_github_app_installation_id
    )

  if param_github_app_enterprise_base_url is not None:
    params["github_app_enterprise_base_url"] = (
      str(param_github_app_enterprise_base_url).lower()
      if isinstance(param_github_app_enterprise_base_url, bool)
      else param_github_app_enterprise_base_url
    )

  if param_proxy is not None:
    params["proxy"] = str(param_proxy).lower() if isinstance(param_proxy, bool) else param_proxy

  if param_project is not None:
    params["project"] = str(param_project).lower() if isinstance(param_project, bool) else param_project

  if param_gcp_service_account_key is not None:
    params["gcp_service_account_key"] = (
      str(param_gcp_service_account_key).lower() if isinstance(param_gcp_service_account_key, bool) else param_gcp_service_account_key
    )

  if param_force_http_basic_auth is not None:
    params["force_http_basic_auth"] = (
      str(param_force_http_basic_auth).lower() if isinstance(param_force_http_basic_auth, bool) else param_force_http_basic_auth
    )

  if param_use_azure_workload_identity is not None:
    params["use_azure_workload_identity"] = (
      str(param_use_azure_workload_identity).lower()
      if isinstance(param_use_azure_workload_identity, bool)
      else param_use_azure_workload_identity
    )

  if param_bearer_token is not None:
    params["bearer_token"] = str(param_bearer_token).lower() if isinstance(param_bearer_token, bool) else param_bearer_token

  if param_insecure_oci_force_http is not None:
    params["insecure_oci_force_http"] = (
      str(param_insecure_oci_force_http).lower() if isinstance(param_insecure_oci_force_http, bool) else param_insecure_oci_force_http
    )

  flat_body = {}
  data = assemble_nested_body(flat_body)

  success, response = await make_api_request(f"/api/v1/repositories/{path_repo}/validate", method="POST", params=params, data=data)

  if not success:
    logger.error(f"Request failed: {response.get('error')}")
    return {"error": response.get("error", "Request failed")}
  return response
